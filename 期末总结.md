# 1.WhyLearnNetworkSecurity

信源 ---(信道)---> 信宿

三网合一：计算机网络、电信网络、有线电视网



计算机系统进行各种数据处理，组成资源子网（外圈的）
通信链路和网络节点提供通信功能，组成通信子网  （内圈的）



## Enigma

转轮机

R是个反射，关键在反射，它使得加密和解密的过程是一样的

看ppt，键盘按下一个键之后，滚轮N先向前移动一格(N0->N1)，然后再读取转换后的字母

解密的时候，好像滚轮初始状态要和加密时一样



# 2.1 Cryptography

密码算法/密码（cipher，c）

c = E(m), m = D(c)

密钥（key, k）

明文有时以m（message）表示，有时以p (plain text)表示



**置换**：重新排列（位置）

**代换**：元素映射为另外一个元素



传统加密：对称加密，发送方和接收方密钥相同

现代加密：非对称加密，发送方和接收方密钥不同



分组密码/块密码：每次处理一个输入分组，相应地输出一个输出分组  

流密码/序列密码 ：流密码/序列密码  



## 古典密码

### 代换技术

#### 单表代换密码

Caesar 密码 （凯撒）：c=( m+3) Mod 26  。 

#### 多表代换密码

Playfair密码：字母矩阵，见2.1ppt P35。一次加密两个字母（分组密码）。若字母对中两字母相同，要有填充符！同行右，同列下，否则每个字母固定行，使用另外一个字母的列。

Hill密码：n个线性方程（最后%26），矩乘

Vigenere：与Caesar 密码不同的是，它是有密钥的，由密钥决定每个明文字母往右移多少位(A=0, Z=25)，密钥自动循环延长至和明文长度一样



一次一密是牢不可破的 ，Vernam密码 ：直接明文和密钥转 0~25 相加模26 得到密文



### 置换技术

比如按行写入，按列读出



### 破译

穷举法、频率分析法（分析字母出现频率以及其他规律/统计特性）



## 对称密码算法

### S-DES (简化DES)

一堆置换、代换、异或的操作，花里胡哨

见ppt P71，注意每个函数是什么。书桌右上柜子里有个练习。（练习中有个swap的问题，注意）



### Feistel密码

扩散：是指使**明文的统计特征**消散在**密文**中，让每个明文数字尽可能地影响多个密文数字  

混淆：是尽可能地使密文和加密**密钥**间的统计关系更复杂，以挫败推导出密钥的企图  



拆分、迭代。这个好像讲得比较简略



### DES

采用分组加密。也是多轮迭代，内部有部分和Feistel结构相同



### 常用的对称密码

3DES，Blowfish，RC5，AES...



# 2.2 Cryptography

## 非对称密码算法

对称密钥密码系统的缺陷：
• 密钥必须经过安全的信道分配
• 无法用于数字签名（验证）
• 密钥管理复杂 ，密钥的数量： O(n2)  

公钥密码是密码学历史上唯一的一次真正的革命。公钥密码是基于**数学函数**而不是代换和置换  



KUa：用户a的公钥 （public）

KRa：用户a的私钥  （private）

$E_{KUa}[P]$： 用KUa对明文P进行加密



公钥：加密，验证签名

私钥：解密，签名 



签名：发送信息，发送端对私钥加密来签名，接收端用对方的公钥解密来验证确实是发送端发过来的



会话密钥：Ks，就是对称密钥里面的，用同一个密钥Ks来加密解密



同时使用数字签名和加密：见ppt P12



公钥密码的数学原理：陷门单向函数。

1. 单向函数是求逆困难的函数  
2. 给定y, 计算x使y=f(x)是困难的  
3. 存在δ，已知δ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是容易的  

单向函数：求逆困难的函数 ，满足1,2点

条件3是陷门性，δ是陷门信息



公钥密码系统除了加密解密、数字签名之外，还有一个用途：

- 密钥交换：双方协商会话密钥，用于对称密钥数据加密  



| 公钥密码算法   | 加密解密 | 数字签名 | 密钥交换 |
| -------------- | -------- | -------- | -------- |
| RSA            | Y        | Y        | Y        |
| Diffie-Hellman | N        | N        | Y        |
| DSA            | N        | Y        | N        |



公钥密码比传统密码更安全 。 **这句话是错误的！**(安全性依赖于密钥长度和破译密文所需要的计算量。不能简单地说传统密码和公钥密码哪个更安全  )

公钥密码是一种通用方法，传统密码已经过时 。 **这句话是错误的！** (公钥密码需要大量计算，仅限于**密钥管理和签名**这类应用中，所以基本不太可能取代传统密码  )

传统密码中与密钥分配中心的握手是一件异常麻烦的事情，而公钥密码实现密钥分配则是非常简单的 。 **这句话是错误的！** (公钥密码实现密钥分配也需要某种形式的协议 ，也很麻烦)



P18 有个对对称密码和公钥密码的总结



### RSA算法

回顾：欧拉函数ф(n) ： n是正整数,ф(n) 是比n小且与n 互素的正整数个数  (ф(6) = 2)

欧拉定理： m,n互素，则$m^{\phi(n)} \equiv 1 (mod\ n)$

RSA算法见P27 28。先取公钥KU={e, n}，私钥KR={d,n}，然后加密解密如下：
$$
C = M^e \mod n \\
M = C^d \mod n
$$
($C=M^e\mod n = C^{de}\mod n = C^{k\phi(n)+1}\mod n = C$)



有一种计时攻击：通过记录计算机解密消息所用的时间来确定私钥  



RSA抗穷举攻击的方法是使用大密钥空间，它比DES慢了100~1000倍。



### DH密钥交换算法 (Diffie-Hellman)

$ind_{a,p} (b)$  ：b 的以a为底，模p的离散对数或指数 ，即$ind = \log_a b\mod p,\quad b = a^{ind} \mod p$

求离散对数是比较困难的（BSGS $O(\sqrt p)$求解）



DH算法过程见P42，使用原根，两个人贡献一部分信息凑出会话密钥



### 密钥分配

密钥分配中心KDC

•情况一：传统的对称密码分配
•情况二：非对称密码中的公钥分配
•情况三：公钥密码用于传统密码体制的密钥分配  



# 3.Authentication

认证=比较

## 消息认证

消息认证就是验证所收到的消息**确实是来自真正的发送方**且**未被修改**的消息。 （数字签名是一种认证技术，他还可以用来抗击发送方否认）



认证函数 ： 产生认证符的函数。分为三类：

- 消息加密：整个消息的密文作为认证符。
- 消息认证码MAC： MAC是消息和密钥的公开函数，它产生定长的值，该值作为认证符。
- Hash函数：它是将任意长的消息映射为定长的hash值的公开函数，以该hash值作为认证符。  



### 消息加密

直接对消息进行加密来认证。



帧校验序列FCS或者校验和来确认消息是真实的。附加在消息后面

必须先计算FCS，再加密！（防止伪造——构造信息以混淆）



对称加密可以提供保密性、认证（这条消息来自A），但是不能提供数字签名（接收方伪造信息、发送方否认信息。数字签名表示我确实曾经写过这个信息！）

而公钥加密都可以提供：保密性、认证、数字签名

可知：共享密钥就不能提供数字签名（因为另一方可以进行篡改），所以MAC也不能提供数字签名



### 消息认证码MAC

算一个MAC来认证。



MAC（消息认证码）是消息和密钥的函数：   $MAC= C_k(M)$

C是MAC函数，K是双方的共享密钥

MAC函数与加密类似，区别就是MAC算法**不要求可逆性 **。



- A和B共享密码K
- A向B发送消息时， A计算MAC，将其附加在消息后面，一起发送给接收方 。接收方也算一个MAC，比较两个MAC



密文有关的认证：先加密，再对密文算MAC。



### Hash函数

算一个hash来认证。单向的hash函数是消息认证码的一种变形 。但是hash不使用密钥，hash具有错误检测能力。

图中的|| 表示拼接，M || Hash(M)



传送时，只对hash值加密就相当于是MAC， $MAC=E_K[H(M)]$

还有用公私钥对hash码进行加密的...



$E_K[M || E_{KRa}[H(M)]]$  这个使用了hash、对称加密、公钥加密，能够同时提供认证、保密性、数字签名（敌营前面的方法）



hash函数的要求：

单向性（求逆困难），抗弱碰撞性（给m，很难找到m'使得$H(m')=H(m)$），抗强碰撞性（很难找到x,y使得$H(x)=H(y)$）

也就是说对于hash函数来说，抗弱碰撞性更强



hash里面重复使用了压缩函数f（比如取模），设计安全hash函数可以归纳为设计具有抗碰撞能力的压缩函数问题，并且该压缩函数的输入是定长的  

**HASH**: CV0=IV是初始值，CVi = f(CVi-1, Yi-1)， 最终的H(M)就为CVL。 f就是压缩函数。

压缩函数抗碰撞，那么hash也抗碰撞



#### MD5 (Message Digest)

MD5被王小云攻破了（碰撞相关）

MD5的**输入**是任意长度的消息，对输入按照512位的**分组**为单位进行处理，算法的**输出**是128位的消息摘要  



- Step1：增加填充位 (第一位填1，后面填0)
- Step2：填充长度。（填充前的长度，小端，64位二进制数，若长度超过$2^{64}$，模一下）（填充了填充位与长度之后，消息为512的倍数）

- Step3：初始化MD 缓存 （就是计算过程中的那个128位，要赋初始值）
- Step4：以512位的分组(16个字)位单位处理消息 （这里面是有多轮运算的）
- Step5：输出  



也是一种特殊的hash，重复使用某一个压缩函数f，只不过这里f是MD5自己的压缩函数。见P47页流程

MD5相比MD4多一轮运算，多使用一个基本逻辑函数



####SHA (Secure Hash Algorithm)

SHA算法建立在MD4之上，基本框架与MD4类似  

**SHA-1**:

输入: 长度小于$2^{64}$位

输出: 160位的消息摘要  (5 * 32)

分组: 以512位为单位进行分组处理  

算法步骤与MD-5一样都是5步，压缩函数变为了SHA-1压缩函数。



#### RIPEMD-160

输入: 长度小于$2^{64}$位

输出: 160位的消息摘要  (5 * 32)

分组: 以512位为单位进行分组处理  

也是那五个步骤



160表示步数，这个步数比MD5和SHA都要长。



三个算法都不容易受到弱碰撞性的攻击。

MD5由于消息摘要短，易于受到强碰撞性的攻击。

上面三个算法，密码分析（就是破译）一个比一个难。

但是MD5执行速度是最快的。

只有SHA-1采用高位在前的结构（大端序）



### 数字签名算法DSS

认证和数字签名的区别：

消息认证可以保证通信双方不受**第三方**的攻击，但是它不能处理通信**双方自身**发生的攻击  （之前说的两种情况，接收方伪造信息、发送方否认信息）。数字签名相当于手写签名，验证签名者、签名日期等。



两类：

直接数字签名：只涉及通信双方 。弱点在于方法的有效性依赖于发送方私钥的安全性  

仲裁数字签名：从发送方X到接收方Y的每条已签名的消息都先发给仲裁者A， A对消息及其签名进行检查以验证消息源及其内容，然后给消息加上日期，并发给Y，同时指明该消息已通过仲裁者的检验  。



DSS只能提供数字签名功能，（给出了一种新的数字签名方法，即数字签名算法DSA  ）

大概是：根据接收到的信息算出一个r（签名由s,r两部分组成），拿算出的r与信息中的r比较，相等则签名有效



## 身份认证

确认行为参与者（主体或客体，通常称为用户）身份的解决方法 。 比如居民身份证、银行卡及密码  等

互联网世界中一切信息（包括各类对象的身份信息）都是用一组特定的数据来表示的  ，因此身份认证的过程也是针对这组特定的数据进行的 。需要大量使用消息认证技术  



### 网站身份认证技术  

超文本传输协议HTTP（ Hyper Text Tansfer Protocol ） 是基于TCP/IP的应用层协议  

- 可以通过HTTP协议传输任意类型的数据对象
- HTTP是面向一次连接的无状态网络协议 （只要一次建立连接，之后就是请求-响应即可） 

最简单的网站用户认证： HTTP的Basic认证。改进解决Basic认证的问题： 基于表单的身份认证 。增强认证：手机短信口令等等。



Basic认证：用户身份凭证：账号+静态口令 。**每次**发出HTTP请求时，把用户身份凭证的明文发送到服务器端，服务器与存储在服务器端的用户凭证进行比较，认证用户身份。

每次都要传递账号和口令，所以安全性低



session机制：一个Session包括特定的客户端、特定的服务器端以及特定的操作时间段  

当某个Session首次启用时，服务器会产生一个唯一的标识符发送到客户端，客户端收到后会存储下来，后续请求都包括这个session，用于身份认证



引入Challenge/Response机制，避免口令明文通过网路传输，并且能避免重放攻击  

使用传输层SSL协议传输HTTP请求   （https）（在传输层对网络连接进行加密  ）



把账号口令进行加密后Ek[U||P)以Cookie机制存放在浏览器客户端   ： 这是不安全的。带来的问题：口令泄露，重放攻击  



**数字证书**：一个经证书授权中心数字签名的文件，最简单的证书包含拥有者的公钥等



# 4.CIA-IPsec-IKE

一个树形图：从上往下，每层依次是：安全目标、安全服务、安全机制、 (算法、实现)



## 安全目标：CIA

Confidentiality + Integrity + Availability

保密性  +  完整性   +  可用性 (比如防DOS)



## 安全服务

•Authentication： 认证服务
•Confidentiality： 保密服务
•Integrity： 数据完整性保护
•Access Control： 访问控制服务
•Non-repudiation： 抗抵赖服务
•Availability： 可用性服务



## 安全机制

。。。



安全性攻击：分为主动攻击和被动攻击。被动攻击包括窃听和监测。



## 网络层安全协议: IPsec !

IPsec: IP + 安全

### 概述

应用层有：S/MIME, PGP, SET

传输层有：SSL, TSL

网络层有：IPSsec



IPsec保障了IP级的安全性，包括：

- 认证：确保来源，未被篡改
- 保密：加密传输，防止窃听
- 密钥管理



IP协议是无状态无连接的

IP packet: 由20 bytes的报头和来自传输层的数据组成



IPSec的原理在于可以在IP层加密和/或认证所有流量  （在网络层实现端到端的安全性）

IPSec的应用：虚拟专用网 VPN， 远程安全访问公司网络

IPSec的实施：主机、防火墙、路由器



### IPSec体系结构

IPSec文档 -> IPSec服务 -> 安全关联SA -> 传输模式 隧道模式

SA：Security Association  安全关联



IPSec服务：AH协议、ESP（只加密）、ESP（加密并认证）

安全关联：IPsec通信双方之间对某些要素的一种协商，一组安全信息参数集合  （协议、操作模式、密码算法等）

AH和ESP均支持两种模式：传输模式和隧道模式

传输模式主要为上层协议提供保护，同时增加了IP包载荷的保护  

隧道模式对整个IP包提供保护  

