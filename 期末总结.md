# 1.WhyLearnNetworkSecurity

信源 ---(信道)---> 信宿

三网合一：计算机网络、电信网络、有线电视网



计算机系统进行各种数据处理，组成资源子网（外圈的）
通信链路和网络节点提供通信功能，组成通信子网  （内圈的）



## Enigma

转轮机

R是个反射，关键在反射，它使得加密和解密的过程是一样的

看ppt，键盘按下一个键之后，滚轮N先向前移动一格(N0->N1)，然后再读取转换后的字母

解密的时候，好像滚轮初始状态要和加密时一样



# 2.1 Cryptography

密码算法/密码（cipher，c）

c = E(m), m = D(c)

密钥（key, k）

明文有时以m（message）表示，有时以p (plain text)表示



**置换**：重新排列（位置）

**代换**：元素映射为另外一个元素



传统加密：对称加密，发送方和接收方密钥相同

现代加密：非对称加密，发送方和接收方密钥不同



分组密码/块密码：每次处理一个输入分组，相应地输出一个输出分组  

流密码/序列密码 ：流密码/序列密码  



## 古典密码

### 代换技术

#### 单表代换密码

Caesar 密码 （凯撒）：c=( m+3) Mod 26  。 

#### 多表代换密码

Playfair密码：字母矩阵，见2.1ppt P35。一次加密两个字母（分组密码）。若字母对中两字母相同，要有填充符！同行右，同列下，否则每个字母固定行，使用另外一个字母的列。

Hill密码：n个线性方程（最后%26），矩乘

Vigenere：与Caesar 密码不同的是，它是有密钥的，由密钥决定每个明文字母往右移多少位(A=0, Z=25)，密钥自动循环延长至和明文长度一样



一次一密是牢不可破的 ，Vernam密码 ：直接明文和密钥转 0~25 相加模26 得到密文



### 置换技术

比如按行写入，按列读出



### 破译

穷举法、频率分析法（分析字母出现频率以及其他规律/统计特性）



## 对称密码算法

### S-DES (简化DES)

一堆置换、代换、异或的操作，花里胡哨

见ppt P71，注意每个函数是什么。书桌右上柜子里有个练习。（练习中有个swap的问题，注意）



### Feistel密码

扩散：是指使**明文的统计特征**消散在**密文**中，让每个明文数字尽可能地影响多个密文数字  

混淆：是尽可能地使密文和加密**密钥**间的统计关系更复杂，以挫败推导出密钥的企图  



拆分、迭代。这个好像讲得比较简略



### DES

采用分组加密。也是多轮迭代，内部有部分和Feistel结构相同



### 常用的对称密码

3DES，Blowfish，RC5，AES...



# 2.2 Cryptography

## 非对称密码算法

对称密钥密码系统的缺陷：
• 密钥必须经过安全的信道分配
• 无法用于数字签名（验证）
• 密钥管理复杂 ，密钥的数量： O(n2)  

公钥密码是密码学历史上唯一的一次真正的革命。公钥密码是基于**数学函数**而不是代换和置换  



KUa：用户a的公钥 （public）

KRa：用户a的私钥  （private）

$E_{KUa}[P]$： 用KUa对明文P进行加密



公钥：加密，验证签名

私钥：解密，签名 



签名：发送信息，发送端对私钥加密来签名，接收端用对方的公钥解密来验证确实是发送端发过来的



会话密钥：Ks，就是对称密钥里面的，用同一个密钥Ks来加密解密



同时使用数字签名和加密：见ppt P12



公钥密码的数学原理：陷门单向函数。

1. 单向函数是求逆困难的函数  
2. 给定y, 计算x使y=f(x)是困难的  
3. 存在δ，已知δ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是容易的  

单向函数：求逆困难的函数 ，满足1,2点

条件3是陷门性，δ是陷门信息



公钥密码系统除了加密解密、数字签名之外，还有一个用途：

- 密钥交换：双方协商会话密钥，用于对称密钥数据加密  



| 公钥密码算法   | 加密解密 | 数字签名 | 密钥交换 |
| -------------- | -------- | -------- | -------- |
| RSA            | Y        | Y        | Y        |
| Diffie-Hellman | N        | N        | Y        |
| DSA            | N        | Y        | N        |



公钥密码比传统密码更安全 。 **这句话是错误的！**(安全性依赖于密钥长度和破译密文所需要的计算量。不能简单地说传统密码和公钥密码哪个更安全  )

公钥密码是一种通用方法，传统密码已经过时 。 **这句话是错误的！** (公钥密码需要大量计算，仅限于**密钥管理和签名**这类应用中，所以基本不太可能取代传统密码  )

传统密码中与密钥分配中心的握手是一件异常麻烦的事情，而公钥密码实现密钥分配则是非常简单的 。 **这句话是错误的！** (公钥密码实现密钥分配也需要某种形式的协议 ，也很麻烦)



P18 有个对对称密码和公钥密码的总结



### RSA算法

回顾：欧拉函数ф(n) ： n是正整数,ф(n) 是比n小且与n 互素的正整数个数  (ф(6) = 2)

欧拉定理： m,n互素，则$m^{\phi(n)} \equiv 1 (mod\ n)$

RSA算法见P27 28。先取公钥KU={e, n}，私钥KR={d,n}，然后加密解密如下：
$$
C = M^e \mod n \\
M = C^d \mod n
$$
($C=M^e\mod n = C^{de}\mod n = C^{k\phi(n)+1}\mod n = C$)



有一种计时攻击：通过记录计算机解密消息所用的时间来确定私钥  



RSA抗穷举攻击的方法是使用大密钥空间，它比DES慢了100~1000倍。



### DH密钥交换算法 (Diffie-Hellman)

$ind_{a,p} (b)$  ：b 的以a为底，模p的离散对数或指数 ，即$ind = \log_a b\mod p,\quad b = a^{ind} \mod p$

求离散对数是比较困难的（BSGS $O(\sqrt p)$求解）



DH算法过程见P42，使用原根，两个人贡献一部分信息凑出会话密钥



### 密钥分配

密钥分配中心KDC

•情况一：传统的对称密码分配
•情况二：非对称密码中的公钥分配
•情况三：公钥密码用于传统密码体制的密钥分配  



# 3.Authentication

认证=比较

## 消息认证

消息认证就是验证所收到的消息**确实是来自真正的发送方**且**未被修改**的消息。 （数字签名是一种认证技术，他还可以用来抗击发送方否认）



认证函数 ： 产生认证符的函数。分为三类：

- 消息加密：整个消息的密文作为认证符。
- 消息认证码MAC： MAC是消息和密钥的公开函数，它产生定长的值，该值作为认证符。
- Hash函数：它是将任意长的消息映射为定长的hash值的公开函数，以该hash值作为认证符。  



### 消息加密

直接对消息进行加密来认证。



帧校验序列FCS或者校验和来确认消息是真实的。附加在消息后面

必须先计算FCS，再加密！（防止伪造——构造信息以混淆）



对称加密可以提供保密性、认证（这条消息来自A），但是不能提供数字签名（接收方伪造信息、发送方否认信息。数字签名表示我确实曾经写过这个信息！）

而公钥加密都可以提供：保密性、认证、数字签名

可知：共享密钥就不能提供数字签名（因为另一方可以进行篡改），所以MAC也不能提供数字签名



### 消息认证码MAC

算一个MAC来认证。



MAC（消息认证码）是消息和密钥的函数：   $MAC= C_k(M)$

C是MAC函数，K是双方的共享密钥

MAC函数与加密类似，区别就是MAC算法**不要求可逆性 **。



- A和B共享密码K
- A向B发送消息时， A计算MAC，将其附加在消息后面，一起发送给接收方 。接收方也算一个MAC，比较两个MAC



密文有关的认证：先加密，再对密文算MAC。



### Hash函数

算一个hash来认证。单向的hash函数是消息认证码的一种变形 。但是hash不使用密钥，hash具有错误检测能力。

图中的|| 表示拼接，M || Hash(M)



传送时，只对hash值加密就相当于是MAC， $MAC=E_K[H(M)]$

还有用公私钥对hash码进行加密的...



$E_K[M || E_{KRa}[H(M)]]$  这个使用了hash、对称加密、公钥加密，能够同时提供认证、保密性、数字签名（敌营前面的方法）



hash函数的要求：

单向性（求逆困难），抗弱碰撞性（给m，很难找到m'使得$H(m')=H(m)$），抗强碰撞性（很难找到x,y使得$H(x)=H(y)$）

也就是说对于hash函数来说，抗弱碰撞性更强



hash里面重复使用了压缩函数f（比如取模），设计安全hash函数可以归纳为设计具有抗碰撞能力的压缩函数问题，并且该压缩函数的输入是定长的  

**HASH**: CV0=IV是初始值，CVi = f(CVi-1, Yi-1)， 最终的H(M)就为CVL。 f就是压缩函数。

压缩函数抗碰撞，那么hash也抗碰撞



#### MD5 (Message Digest)

MD5被王小云攻破了（碰撞相关）

MD5的**输入**是任意长度的消息，对输入按照512位的**分组**为单位进行处理，算法的**输出**是128位的消息摘要  



- Step1：增加填充位 (第一位填1，后面填0)
- Step2：填充长度。（填充前的长度，小端，64位二进制数，若长度超过$2^{64}$，模一下）（填充了填充位与长度之后，消息为512的倍数）

- Step3：初始化MD 缓存 （就是计算过程中的那个128位，要赋初始值）
- Step4：以512位的分组(16个字)位单位处理消息 （这里面是有多轮运算的）
- Step5：输出  



也是一种特殊的hash，重复使用某一个压缩函数f，只不过这里f是MD5自己的压缩函数。见P47页流程

MD5相比MD4多一轮运算，多使用一个基本逻辑函数



####SHA (Secure Hash Algorithm)

SHA算法建立在MD4之上，基本框架与MD4类似  

**SHA-1**:

输入: 长度小于$2^{64}$位

输出: 160位的消息摘要  (5 * 32)

分组: 以512位为单位进行分组处理  

算法步骤与MD-5一样都是5步，压缩函数变为了SHA-1压缩函数。



#### RIPEMD-160

输入: 长度小于$2^{64}$位

输出: 160位的消息摘要  (5 * 32)

分组: 以512位为单位进行分组处理  

也是那五个步骤



160表示步数，这个步数比MD5和SHA都要长。



三个算法都不容易受到弱碰撞性的攻击。

MD5由于消息摘要短，易于受到强碰撞性的攻击。

上面三个算法，密码分析（就是破译）一个比一个难。

但是MD5执行速度是最快的。

只有SHA-1采用高位在前的结构（大端序）



### 数字签名算法DSS

认证和数字签名的区别：

消息认证可以保证通信双方不受**第三方**的攻击，但是它不能处理通信**双方自身**发生的攻击  （之前说的两种情况，接收方伪造信息、发送方否认信息）。数字签名相当于手写签名，验证签名者、签名日期等。



两类：

直接数字签名：只涉及通信双方 。弱点在于方法的有效性依赖于发送方私钥的安全性  

仲裁数字签名：从发送方X到接收方Y的每条已签名的消息都先发给仲裁者A， A对消息及其签名进行检查以验证消息源及其内容，然后给消息加上日期，并发给Y，同时指明该消息已通过仲裁者的检验  。



DSS只能提供数字签名功能，（给出了一种新的数字签名方法，即数字签名算法DSA  ）

